<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>锂电池电芯计算器</title>
    <!-- 使用单一CDN直接内联加载Three.js和OrbitControls，确保版本匹配和依赖关系 -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
            background-color: #ffffff;
            color: #1d1d1f;
            line-height: 1.4;
            overflow-x: hidden;
        }
        .container {
            background-color: #ffffff;
            padding: 0;
            border-radius: 20px;
            max-width: 600px;
            margin: 0 auto;
        }
        h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -0.003em;
            text-align: center;
        }
        p {
            font-size: 15px;
            color: #86868b;
            margin-bottom: 20px;
            text-align: center;
        }
        .input-group {
            margin-bottom: 20px;
            background-color: #f5f5f7;
            padding: 15px;
            border-radius: 12px;
        }
        .input-section {
            padding: 0 10px; /* 为输入区域添加左右内边距 */
        }
        .input-group h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1d1d1f;
        }
        .flex-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* 增加元素之间的间距 */
            justify-content: space-between;
        }
        .input-item {
            flex: 1;
            min-width: 28%; /* 确保每个项不会太窄 */
            margin: 0 5px; /* 添加左右外边距 */
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #1d1d1f;
            font-size: 15px;
        }
        input[type="number"] {
            display: block;
            width: 90%; /* 从100%减少到90%，防止过宽导致重叠 */
            padding: 8px; /* 从10px减小到8px */
            margin: 5px auto; /* 从10px减小到5px */
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px; /* 从16px减小到14px */
            outline: none;
            transition: all 0.3s ease;
            box-sizing: border-box; /* 确保padding和border不会增加元素宽度 */
        }
        
        input[type="number"]:focus {
            border-color: #0071e3;
            box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.2);
        }
        
        input[type="number"].filled {
            background-color: #f2f9ff; /* 浅蓝色背景表示已填写 */
            border-color: #0071e3;
        }
        
        input:focus {
            outline: none;
            border-color: #0071e3;
            box-shadow: 0 0 0 3px rgba(0,113,227,0.15);
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            background-color: #0071e3;
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            flex: 1;
        }
        button:hover {
            background-color: #0077ed;
            transform: scale(1.02);
        }
        #result {
            margin: 20px 0;
            padding: 20px;
            border-radius: 12px;
            background-color: #f5f5f7;
            display: none;
        }
        #result h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1d1d1f;
        }
        #result-text {
            font-size: 15px;
            line-height: 1.4;
        }
        canvas {
            border-radius: 12px;
            margin: 15px auto;
            background-color: #ffffff;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            max-width: 100%;
            display: block;
        }
        .saved-cell {
            margin: 20px 0;
            padding: 15px;
            background-color: #f5f5f7;
            border-radius: 12px;
        }
        .saved-cell h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1d1d1f;
        }
        #saved-dimensions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .saved-cell button {
            background-color: #ffffff;
            color: #0071e3;
            border: 1px solid #d2d2d7;
            margin: 0;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 400;
            flex: none;
        }
        .saved-cell button:hover {
            background-color: #f5f5f7;
            border-color: #0071e3;
        }
        #clear-button {
            background-color: #86868b;
        }
        #clear-button:hover {
            background-color: #6e6e73;
        }
        .views-container h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 20px 0 15px 0;
            color: #1d1d1f;
        }
        @media (max-width: 768px) {
            .input-container {
                display: flex;
                flex-direction: column;
            }
            
            .input-section {
                width: 100%;
                margin-bottom: 20px;
            }
            
            input[type="number"] {
                width: 100%;
                margin: 8px 0;
            }
        }
        @media (max-width: 600px) {
            body {
                padding: 5px; /* 从8px减小到5px */
            }
            h1 {
                font-size: 20px; /* 从22px减小到20px */
                margin-bottom: 5px; /* 减小底部间距 */
            }
            p {
                font-size: 13px; /* 从14px减小到13px */
                margin-bottom: 10px; /* 从15px减小到10px */
            }
            .input-group {
                padding: 8px; /* 从10px减小到8px */
                margin-bottom: 10px; /* 从15px减小到10px */
            }
            .input-group h3 {
                font-size: 15px; /* 从16px减小到15px */
                margin-bottom: 5px; /* 从10px减小到5px */
            }
            .flex-row {
                flex-direction: row; /* 改为水平布局 */
                flex-wrap: nowrap; /* 不换行 */
                gap: 3px; /* 从5px减小到3px */
                justify-content: space-between;
            }
            .input-item {
                margin: 1px 0; /* 从2px减小到1px */
                min-width: auto; /* 取消最小宽度限制 */
                flex: 1; /* 均分可用空间 */
            }
            .input-field {
                margin-bottom: 2px; /* 从4px减小到2px */
            }
            
            .input-field label {
                width: 25px; /* 从35px减小到25px */
                font-size: 12px; /* 从13px减小到12px */
                margin-right: 2px; /* 减小右边距 */
            }
            
            input[type="number"] {
                padding: 4px; /* 从6px减小到4px */
                font-size: 12px; /* 从13px减小到12px */
                height: 26px; /* 从28px减小到26px */
                width: 100%; /* 占满容器 */
                box-sizing: border-box;
            }
            .saved-cell {
                margin: 8px 0; /* 从10px减小到8px */
                padding: 6px; /* 从8px减小到6px */
            }
            .saved-cell h3 {
                font-size: 15px; /* 从16px减小到15px */
                margin-bottom: 4px; /* 从5px减小到4px */
            }
            .saved-cell button {
                padding: 2px 4px; /* 减小按钮内边距 */
                font-size: 11px; /* 从12px减小到11px */
                margin: 1px; /* 从2px减小到1px */
            }
            .btn-group {
                gap: 5px; /* 从10px减小到5px */
                margin-bottom: 8px; /* 从10px减小到8px */
            }
            button {
                padding: 6px 8px; /* 从6px 10px减小到6px 8px */
                font-size: 13px; /* 从14px减小到13px */
            }
            .container {
                padding: 0 3px;
            }
            /* 让保存的电芯尺寸更紧凑 */
            #saved-dimensions {
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-start;
                gap: 2px;
            }
            .views-container {
                margin-top: 5px;
            }
            .views-container h3 {
                margin: 5px 0;
                font-size: 15px;
            }
            canvas {
                width: 100%;
                height: auto;
            }
            table {
                display: table; 
                width: 100%;
                min-width: 0;
                max-width: 100%;
                table-layout: fixed;
                font-size: 12px;
            }
            #digital-info-container {
                padding: 12px 5px;
                width: auto;
            }
            #digital-info-container table {
                font-size: 12px;
            }
            #digital-info-container table th,
            #digital-info-container table td {
                padding: 6px 2px;
                word-break: keep-all;
                white-space: nowrap;
            }
            .views-container {
                transform: scale(0.95);
                transform-origin: left top;
            }
            #3d-container {
                height: 450px !important; /* 原来是350px，改为450px */
            }
        }

        .input-field {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .input-field label {
            width: 45px;
            margin-right: 5px;
            margin-bottom: 0;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>锂电池电芯计算器</h1>
        <p>输入电池外壳和电芯尺寸（厘米）</p>
        
        <div class="input-group">
            <h3>电池外壳尺寸：</h3>
            <div class="flex-row">
                <div class="input-item">
                    <div class="input-field">
                        <label>长：</label>
                        <input type="number" id="case-length" min="0" step="0.1" value="30" onkeypress="handleEnter(event, 'case-width')">
                    </div>
                </div>
                <div class="input-item">
                    <div class="input-field">
                        <label>宽：</label>
                        <input type="number" id="case-width" min="0" step="0.1" value="60" onkeypress="handleEnter(event, 'case-height')">
                    </div>
                </div>
                <div class="input-item">
                    <div class="input-field">
                        <label>高：</label>
                        <input type="number" id="case-height" min="0" step="0.1" value="60" onkeypress="handleEnter(event, 'cell-length')">
                    </div>
                </div>
            </div>
        </div>

        <div class="saved-cell">
            <h3>已保存的电芯尺寸：</h3>
            <div id="saved-dimensions"></div>
        </div>

        <div class="input-group">
            <h3>电芯尺寸：</h3>
            <div class="flex-row">
                <div class="input-item">
                    <div class="input-field">
                        <label>长：</label>
                        <input type="number" id="cell-length" min="0" step="0.1" value="33" onkeypress="handleEnter(event, 'cell-width')" onchange="saveCellDimensions()">
                    </div>
                </div>
                <div class="input-item">
                    <div class="input-field">
                        <label>宽：</label>
                        <input type="number" id="cell-width" min="0" step="0.1" value="10.1" onkeypress="handleEnter(event, 'cell-height')" onchange="saveCellDimensions()">
                    </div>
                </div>
                <div class="input-item">
                    <div class="input-field">
                        <label>高：</label>
                        <input type="number" id="cell-height" min="0" step="0.1" value="13" onkeypress="handleEnter(event, 'calculate-button')" onchange="saveCellDimensions()">
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group">
            <button id="calculate-button" onclick="calculate()">计算</button>
            <button id="clear-button" onclick="clearInputs()">清除</button>
        </div>

        <div id="result">
            <h3>计算结果：</h3>
            <p id="result-text"></p>
        </div>
    </div>

    <script>
        // 定义全局变量
        const isMobile = window.innerWidth <= 600;
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        
        // 页面加载时加载保存的电芯尺寸
        window.onload = function() {
            loadSavedDimensions();
        };

        // 处理回车键
        function handleEnter(event, nextElementId) {
            if (event.key === 'Enter') {
                event.preventDefault();
                if (nextElementId === 'calculate-button') {
                    calculate();
                } else {
                    document.getElementById(nextElementId).focus();
                }
            }
        }

        // 保存电芯尺寸
        function saveCellDimensions() {
            const length = document.getElementById('cell-length').value;
            const width = document.getElementById('cell-width').value;
            const height = document.getElementById('cell-height').value;
            
            if (length && width && height) {
                const dimensions = {
                    length: length,
                    width: width,
                    height: height,
                    timestamp: new Date().getTime()
                };

                let saved = JSON.parse(localStorage.getItem('savedCellDimensions') || '[]');
                // 最多保存5组数据
                saved = [dimensions, ...saved.slice(0, 4)];
                localStorage.setItem('savedCellDimensions', JSON.stringify(saved));
                
                loadSavedDimensions();
            }
        }

        // 加载保存的电芯尺寸
        function loadSavedDimensions() {
            const saved = JSON.parse(localStorage.getItem('savedCellDimensions') || '[]');
            const container = document.getElementById('saved-dimensions');
            container.innerHTML = '';

            saved.forEach((dim, index) => {
                const button = document.createElement('button');
                button.textContent = `${dim.length} × ${dim.width} × ${dim.height} 厘米`;
                button.onclick = () => loadDimension(dim);
                container.appendChild(button);
            });
        }

        // 加载选中的电芯尺寸
        function loadDimension(dim) {
            document.getElementById('cell-length').value = dim.length;
            document.getElementById('cell-width').value = dim.width;
            document.getElementById('cell-height').value = dim.height;
        }

        function calculate() {
            try {
                console.log('开始计算...');
                // 获取输入值
                const caseLength = Number(document.getElementById('case-length').value);
                const caseWidth = Number(document.getElementById('case-width').value);
                const caseHeight = Number(document.getElementById('case-height').value);
                
                const cellLength = Number(document.getElementById('cell-length').value);
                const cellWidth = Number(document.getElementById('cell-width').value);
                const cellHeight = Number(document.getElementById('cell-height').value);

                // 检查输入是否有效
                if (!caseLength || !caseWidth || !caseHeight || !cellLength || !cellWidth || !cellHeight) {
                    alert('请填写所有尺寸！');
                    return;
                }
                
                // 计算电芯的6种可能摆放方向
                // 每种方向都用 [x轴方向尺寸, y轴方向尺寸, z轴方向尺寸] 表示电芯的放置方式
                const orientations = [
                    {
                        dims: [cellLength, cellWidth, cellHeight],
                        name: "长-宽-高"
                    },
                    {
                        dims: [cellLength, cellHeight, cellWidth],
                        name: "长-高-宽"
                    },
                    {
                        dims: [cellWidth, cellLength, cellHeight],
                        name: "宽-长-高"
                    },
                    {
                        dims: [cellWidth, cellHeight, cellLength],
                        name: "宽-高-长"
                    },
                    {
                        dims: [cellHeight, cellLength, cellWidth],
                        name: "高-长-宽"
                    },
                    {
                        dims: [cellHeight, cellWidth, cellLength],
                        name: "高-宽-长"
                    }
                ];
                
                // 解决最多电芯问题的新方法：允许混合摆放
                // 1. 首先找出最优的单一摆放方案作为基准
                let bestSingleArrangement = findBestSingleArrangement(caseLength, caseWidth, caseHeight, orientations);
                
                // 2. 尝试混合摆放方案
                let bestMixedArrangement = findBestMixedArrangement(caseLength, caseWidth, caseHeight, orientations);
                
                // 3. 对比两种方案，选择电芯数量更多的
                let finalArrangement;
                let isMixed = false;
                
                if (bestMixedArrangement.cellCount > bestSingleArrangement.cellCount) {
                    finalArrangement = bestMixedArrangement;
                    isMixed = true;
                } else {
                    finalArrangement = bestSingleArrangement;
                }
                
                // 显示结果
                const resultDiv = document.getElementById('result');
                const resultText = document.getElementById('result-text');
                resultDiv.style.display = 'block';
                
                // 如果是混合摆放，展示不同
                if (isMixed) {
                    let orientationText = '';
                    let totalCellCount = 0;
                    
                    // 为每个区域创建详细信息
                    finalArrangement.arrangements.forEach((arr, index) => {
                        totalCellCount += arr.count;
                        const orientationName = arr.orientation.name;
                        const dimX = arr.orientation.dims[0];
                        const dimY = arr.orientation.dims[1];
                        const dimZ = arr.orientation.dims[2];
                        
                        // 计算区域尺寸
                        const regionWidth = arr.region.x[1] - arr.region.x[0];
                        const regionHeight = arr.region.z[1] - arr.region.z[0];
                        const regionDepth = arr.region.y[1] - arr.region.y[0];
                        
                        // 创建区域信息
                        orientationText += `
                            <div style="margin-bottom: 12px; padding: 10px; background-color: ${index % 2 === 0 ? '#f0f7ff' : '#fff4f0'}; border-radius: 8px;">
                                <div style="font-weight: 600; margin-bottom: 5px; color: #0071e3;">区域 ${index + 1} (${orientationName}):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                                    <div style="flex: 1; min-width: 180px;">
                                        <div>电芯数量: <strong>${arr.count}</strong> 块 (${arr.countX}×${arr.countY}×${arr.countZ})</div>
                                        <div>电芯尺寸: ${dimX}×${dimY}×${dimZ} cm</div>
                                    </div>
                                    <div style="flex: 1; min-width: 180px;">
                                        <div>区域尺寸: ${regionWidth.toFixed(2)}×${regionDepth.toFixed(2)}×${regionHeight.toFixed(2)} cm</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    // 计算空间利用率
                    const totalVolume = caseLength * caseWidth * caseHeight;
                    let usedVolume = 0;
                    finalArrangement.arrangements.forEach(arr => {
                        const [dimX, dimY, dimZ] = arr.orientation.dims;
                        usedVolume += arr.count * dimX * dimY * dimZ;
                    });
                    const utilization = (usedVolume / totalVolume * 100).toFixed(1);
                    
                    resultText.innerHTML = `
                        <div style="margin-bottom: 15px; padding: 15px; background-color: #e3f2fd; border-radius: 10px;">
                            <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">最优混合摆放方案</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                                <div style="flex: 1; min-width: 200px;">
                                    <div style="margin-bottom: 5px;"><span style="color: #0071e3;">电芯总数:</span> <strong style="font-size: 1.1em;">${totalCellCount}</strong> 块</div>
                                    <div><span style="color: #0071e3;">空间利用率:</span> ${utilization}%</div>
                                </div>
                                <div style="flex: 1; min-width: 200px;">
                                    <div style="margin-bottom: 5px;"><span style="color: #0071e3;">外壳尺寸:</span> ${caseLength}×${caseWidth}×${caseHeight} cm</div>
                                    <div><span style="color: #0071e3;">区域数量:</span> ${finalArrangement.arrangements.length} 个区域</div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <div style="font-weight: 600; margin-bottom: 10px;">区域详情:</div>
                            ${orientationText}
                        </div>
                        <div style="font-size: 0.9em; color: #666; margin-top: 10px;">
                            <p>混合摆放方案对电芯进行分区域排列，每个区域采用不同的电芯摆放方向，以最大化利用可用空间。</p>
                        </div>
                    `;
                } else {
                    // 使用原有的单一方向显示方式
                    const arrangementDisplay = finalArrangement.arrangement.name;
                    
                    resultText.innerHTML = `
                        <div style="margin-bottom: 10px;">最多可以放置 <strong style="font-size: 1.2em;">${finalArrangement.cellCount}</strong> 块电芯</div>
                        <div style="margin-bottom: 10px;">摆放方式: <strong>${arrangementDisplay}</strong> (${finalArrangement.countX} × ${finalArrangement.countY} × ${finalArrangement.countZ})</div>
                        <div style="font-size: 0.9em; color: #666;">
                            <p>单一方向摆放是最优解，无需混合摆放。请查看下方的3D视图了解详细摆放方式。</p>
                        </div>
                    `;
                }

                console.log('开始绘制示意图...');
                
                // 绘制示意图，对于混合摆放可能需要特殊处理
                try {
                    if (isMixed) {
                        console.log('绘制混合摆放示意图');
                        drawMixedDiagram(finalArrangement, caseLength, caseWidth, caseHeight, cellLength, cellWidth, cellHeight);
                    } else {
                        console.log('绘制单一摆放示意图');
                        drawDiagram(
                            finalArrangement.countX, 
                            finalArrangement.countY, 
                            finalArrangement.countZ, 
                            finalArrangement.arrangement.dims[0],
                            finalArrangement.arrangement.dims[1],
                            finalArrangement.arrangement.dims[2],
                            finalArrangement.arrangement.name
                        );
                    }
                    console.log('示意图绘制完成');
                } catch (diagramError) {
                    console.error('绘制示意图时出错:', diagramError);
                    alert('绘制示意图时出错: ' + diagramError.message);
                }
            } catch (e) {
                console.error('计算时出错:', e);
                alert('计算时出错: ' + e.message);
            }
        }

        // 寻找最佳单一方向摆放方案
        function findBestSingleArrangement(caseLength, caseWidth, caseHeight, orientations) {
            let optimalArrangement = null;
            let maxCellCount = 0;
            let maxUtilization = 0;
            
            orientations.forEach(orientation => {
                const [dimX, dimY, dimZ] = orientation.dims;
                
                // 计算每个方向最多能放置的数量
                const countX = Math.floor(caseLength / dimX);
                const countY = Math.floor(caseWidth / dimY);
                const countZ = Math.floor(caseHeight / dimZ);
                
                // 计算总电芯数和空间利用率
                const cellCount = countX * countY * countZ;
                const cellVolume = dimX * dimY * dimZ;
                const volumeUsed = cellCount * cellVolume;
                const totalVolume = caseLength * caseWidth * caseHeight;
                const utilization = volumeUsed / totalVolume;
                
                // 如果当前方式比最优方式更好，则更新最优方式
                if (cellCount > maxCellCount || (cellCount === maxCellCount && utilization > maxUtilization)) {
                    maxCellCount = cellCount;
                    maxUtilization = utilization;
                    optimalArrangement = {
                        arrangement: orientation,
                        countX: countX,
                        countY: countY,
                        countZ: countZ,
                        cellCount: cellCount,
                        utilization: utilization,
                        remainderX: caseLength - countX * dimX,
                        remainderY: caseWidth - countY * dimY,
                        remainderZ: caseHeight - countZ * dimZ,
                        volumeUsed: volumeUsed,
                        volumeRemaining: totalVolume - volumeUsed
                    };
                }
            });
            
            return optimalArrangement;
        }

        // 寻找最佳混合摆放方案
        function findBestMixedArrangement(caseLength, caseWidth, caseHeight, orientations) {
            // 先找到最佳的单一方向作为基准
            const baseSolution = findBestSingleArrangement(caseLength, caseWidth, caseHeight, orientations);
            let bestMixedCellCount = baseSolution.cellCount;
            let bestMixedArrangement = {
                cellCount: baseSolution.cellCount,
                remainderX: baseSolution.remainderX,
                remainderY: baseSolution.remainderY,
                remainderZ: baseSolution.remainderZ,
                arrangements: [
                    {
                        orientation: baseSolution.arrangement,
                        count: baseSolution.cellCount,
                        countX: baseSolution.countX,
                        countY: baseSolution.countY,
                        countZ: baseSolution.countZ
                    }
                ]
            };
            
            // 递归函数：尝试在给定空间中找到最优的摆放方式
            function findBestArrangementInSpace(spaceLength, spaceWidth, spaceHeight, depth = 0, maxDepth = 4) {
                // 防止递归过深
                if (depth >= maxDepth) return { count: 0, arrangements: [] };
                
                // 如果空间太小，无法放置任何电芯，直接返回
                const minDimension = Math.min(...orientations.map(o => Math.min(...o.dims)));
                if (spaceLength < minDimension && spaceWidth < minDimension && spaceHeight < minDimension) {
                    return { count: 0, arrangements: [] };
                }
                
                let bestCount = 0;
                let bestArrangements = [];
                
                // 先尝试用单一方向填满整个空间
                const singleArrangement = findBestSingleArrangement(spaceLength, spaceWidth, spaceHeight, orientations);
                if (singleArrangement) {
                    bestCount = singleArrangement.cellCount;
                    bestArrangements = [{
                        orientation: singleArrangement.arrangement,
                        count: singleArrangement.cellCount,
                        countX: singleArrangement.countX,
                        countY: singleArrangement.countY,
                        countZ: singleArrangement.countZ,
                        region: {
                            x: [0, spaceLength],
                            y: [0, spaceWidth],
                            z: [0, spaceHeight]
                        }
                    }];
                    
                    // 检查单一方向是否完全利用了空间
                    const [dimX, dimY, dimZ] = singleArrangement.arrangement.dims;
                    const usedX = singleArrangement.countX * dimX;
                    const usedY = singleArrangement.countY * dimY;
                    const usedZ = singleArrangement.countZ * dimZ;
                    
                    // 如果空间利用率已经达到95%以上，直接返回当前方案
                    const volumeUsed = usedX * usedY * usedZ;
                    const totalVolume = spaceLength * spaceWidth * spaceHeight;
                    if (volumeUsed / totalVolume > 0.95) {
                        return { count: bestCount, arrangements: bestArrangements };
                    }
                }
                
                // 然后尝试分割空间 - 增强版本：考虑电芯旋转
                
                // 遍历所有可能的主空间电芯摆放方式
                for (let mainOrientation of orientations) {
                    const [mainDimX, mainDimY, mainDimZ] = mainOrientation.dims;
                    
                    // X方向分割
                    const mainCountX = Math.floor(spaceLength / mainDimX);
                    if (mainCountX > 0) {
                        const mainUsedX = mainCountX * mainDimX;
                        const mainCountY = Math.floor(spaceWidth / mainDimY);
                        const mainCountZ = Math.floor(spaceHeight / mainDimZ);
                        const mainCount = mainCountX * mainCountY * mainCountZ;
                        
                        const remainingX = spaceLength - mainUsedX;
                        
                        // 只有当剩余空间足够大，值得进一步处理时才继续
                        if (remainingX > 0 && remainingX >= minDimension) {
                            // 递归寻找剩余空间的最佳摆放，并考虑所有可能的电芯旋转摆放
                            const remainingResult = findBestArrangementInSpace(remainingX, spaceWidth, spaceHeight, depth + 1, maxDepth);
                            
                            if (mainCount + remainingResult.count > bestCount) {
                                bestCount = mainCount + remainingResult.count;
                                bestArrangements = [{
                                    orientation: mainOrientation,
                                    count: mainCount,
                                    countX: mainCountX,
                                    countY: mainCountY,
                                    countZ: mainCountZ,
                                    region: {
                                        x: [0, mainUsedX],
                                        y: [0, spaceWidth],
                                        z: [0, spaceHeight]
                                    }
                                }, ...remainingResult.arrangements.map(arr => {
                                    // 调整区域坐标
                                    const region = {...arr.region};
                                    region.x = [region.x[0] + mainUsedX, region.x[1] + mainUsedX];
                                    return {...arr, region};
                                })];
                        }
                    }
                }
                
                // Y方向分割
                    const mainCountY = Math.floor(spaceWidth / mainDimY);
                    if (mainCountY > 0) {
                        const mainUsedY = mainCountY * mainDimY;
                        const mainCountX = Math.floor(spaceLength / mainDimX);
                        const mainCountZ = Math.floor(spaceHeight / mainDimZ);
                        const mainCount = mainCountX * mainCountY * mainCountZ;
                        
                        const remainingY = spaceWidth - mainUsedY;
                        
                        if (remainingY > 0 && remainingY >= minDimension) {
                            // 递归寻找剩余空间的最佳摆放
                            const remainingResult = findBestArrangementInSpace(spaceLength, remainingY, spaceHeight, depth + 1, maxDepth);
                            
                            if (mainCount + remainingResult.count > bestCount) {
                                bestCount = mainCount + remainingResult.count;
                                bestArrangements = [{
                                    orientation: mainOrientation,
                                    count: mainCount,
                                    countX: mainCountX,
                                    countY: mainCountY,
                                    countZ: mainCountZ,
                                    region: {
                                        x: [0, spaceLength],
                                        y: [0, mainUsedY],
                                        z: [0, spaceHeight]
                                    }
                                }, ...remainingResult.arrangements.map(arr => {
                                    // 调整区域坐标
                                    const region = {...arr.region};
                                    region.y = [region.y[0] + mainUsedY, region.y[1] + mainUsedY];
                                    return {...arr, region};
                                })];
                        }
                    }
                }
                
                // Z方向分割
                    const mainCountZ = Math.floor(spaceHeight / mainDimZ);
                    if (mainCountZ > 0) {
                        const mainUsedZ = mainCountZ * mainDimZ;
                        const mainCountX = Math.floor(spaceLength / mainDimX);
                        const mainCountY = Math.floor(spaceWidth / mainDimY);
                        const mainCount = mainCountX * mainCountY * mainCountZ;
                        
                        const remainingZ = spaceHeight - mainUsedZ;
                        
                        if (remainingZ > 0 && remainingZ >= minDimension) {
                            // 递归寻找剩余空间的最佳摆放
                            const remainingResult = findBestArrangementInSpace(spaceLength, spaceWidth, remainingZ, depth + 1, maxDepth);
                            
                            if (mainCount + remainingResult.count > bestCount) {
                                bestCount = mainCount + remainingResult.count;
                                bestArrangements = [{
                                    orientation: mainOrientation,
                                    count: mainCount,
                                    countX: mainCountX,
                                    countY: mainCountY,
                                    countZ: mainCountZ,
                                    region: {
                                        x: [0, spaceLength],
                                        y: [0, spaceWidth],
                                        z: [0, mainUsedZ]
                                    }
                                }, ...remainingResult.arrangements.map(arr => {
                                    // 调整区域坐标
                                    const region = {...arr.region};
                                    region.z = [region.z[0] + mainUsedZ, region.z[1] + mainUsedZ];
                                    return {...arr, region};
                                })];
                            }
                        }
                    }
                    
                    // 复合分割：考虑同时在X和Y方向分割，形成L形摆放
                    // 此策略适用于主区域用完后，有两个方向都有剩余空间的情况
                    if (mainCountX > 0 && mainCountY > 0) {
                        const mainUsedX = mainCountX * mainDimX;
                        const mainUsedY = mainCountY * mainDimY;
                        const mainCount = mainCountX * mainCountY * mainCountZ;
                        
                        const remainingX = spaceLength - mainUsedX;
                        const remainingY = spaceWidth - mainUsedY;
                        
                        // 只有当两个方向都有足够的剩余空间时才继续
                        if (remainingX > 0 && remainingY > 0 && 
                            (remainingX >= minDimension || remainingY >= minDimension)) {
                            
                            // 尝试右侧区域 (剩余X, 全Y)
                            const rightResult = findBestArrangementInSpace(remainingX, spaceWidth, spaceHeight, depth + 1, maxDepth);
                            
                            // 尝试下方区域 (全X, 剩余Y)
                            const bottomResult = findBestArrangementInSpace(spaceLength, remainingY, spaceHeight, depth + 1, maxDepth);
                            
                            // 选择右侧或下方更好的方案
                            if (rightResult.count > bottomResult.count) {
                                if (mainCount + rightResult.count > bestCount) {
                                    bestCount = mainCount + rightResult.count;
                                    bestArrangements = [{
                                        orientation: mainOrientation,
                                        count: mainCount,
                                        countX: mainCountX,
                                        countY: mainCountY,
                                        countZ: mainCountZ,
                                        region: {
                                            x: [0, mainUsedX],
                                            y: [0, spaceWidth],
                                            z: [0, spaceHeight]
                                        }
                                    }, ...rightResult.arrangements.map(arr => {
                                        // 调整区域坐标
                                        const region = {...arr.region};
                                        region.x = [region.x[0] + mainUsedX, region.x[1] + mainUsedX];
                                        return {...arr, region};
                                    })];
                                }
                            } else {
                                if (mainCount + bottomResult.count > bestCount) {
                                    bestCount = mainCount + bottomResult.count;
                                    bestArrangements = [{
                                        orientation: mainOrientation,
                                        count: mainCount,
                                        countX: mainCountX,
                                        countY: mainCountY,
                                        countZ: mainCountZ,
                                        region: {
                                            x: [0, spaceLength],
                                            y: [0, mainUsedY],
                                            z: [0, spaceHeight]
                                        }
                                    }, ...bottomResult.arrangements.map(arr => {
                                        // 调整区域坐标
                                        const region = {...arr.region};
                                        region.y = [region.y[0] + mainUsedY, region.y[1] + mainUsedY];
                                        return {...arr, region};
                                    })];
                                }
                            }
                            
                            // 尝试L形区域划分：主区域 + 右侧区域 + 剩余的L形区域
                            // 这是最复杂的情况，需要考虑三个区域
                            const rightSpace = {
                                length: remainingX,
                                width: mainUsedY,
                                height: spaceHeight
                            };
                            const bottomSpace = {
                                length: mainUsedX,
                                width: remainingY,
                                height: spaceHeight
                            };
                            const cornerSpace = {
                                length: remainingX,
                                width: remainingY,
                                height: spaceHeight
                            };
                            
                            // 尝试右侧矩形区域
                            const rightSectionResult = findBestArrangementInSpace(
                                rightSpace.length, rightSpace.width, rightSpace.height, 
                                depth + 1, maxDepth
                            );
                            
                            // 尝试底部矩形区域
                            const bottomSectionResult = findBestArrangementInSpace(
                                bottomSpace.length, bottomSpace.width, bottomSpace.height, 
                                depth + 1, maxDepth
                            );
                            
                            // 尝试角落矩形区域
                            const cornerSectionResult = findBestArrangementInSpace(
                                cornerSpace.length, cornerSpace.width, cornerSpace.height, 
                                depth + 1, maxDepth
                            );
                            
                            // 计算总电芯数
                            const totalLShapeCount = mainCount + rightSectionResult.count + 
                                                   bottomSectionResult.count + cornerSectionResult.count;
                            
                            if (totalLShapeCount > bestCount) {
                                bestCount = totalLShapeCount;
                                bestArrangements = [
                                    // 主区域
                                    {
                                        orientation: mainOrientation,
                                        count: mainCount,
                                        countX: mainCountX,
                                        countY: mainCountY,
                                        countZ: mainCountZ,
                                        region: {
                                            x: [0, mainUsedX],
                                            y: [0, mainUsedY],
                                            z: [0, spaceHeight]
                                        }
                                    },
                                    // 右侧区域
                                    ...rightSectionResult.arrangements.map(arr => {
                                        const region = {...arr.region};
                                        region.x = [region.x[0] + mainUsedX, region.x[1] + mainUsedX];
                                        return {...arr, region};
                                    }),
                                    // 底部区域
                                    ...bottomSectionResult.arrangements.map(arr => {
                                        const region = {...arr.region};
                                        region.y = [region.y[0] + mainUsedY, region.y[1] + mainUsedY];
                                        return {...arr, region};
                                    }),
                                    // 角落区域
                                    ...cornerSectionResult.arrangements.map(arr => {
                                        const region = {...arr.region};
                                        region.x = [region.x[0] + mainUsedX, region.x[1] + mainUsedX];
                                        region.y = [region.y[0] + mainUsedY, region.y[1] + mainUsedY];
                                        return {...arr, region};
                                    })
                                ];
                            }
                        }
                    }
                }
                
                return { count: bestCount, arrangements: bestArrangements };
            }
            
            // 使用递归方法寻找最佳混合排列
            const recursiveResult = findBestArrangementInSpace(caseLength, caseWidth, caseHeight);
            
            // 如果递归方法找到的方案比之前的方案更好，则更新
            if (recursiveResult.count > bestMixedCellCount) {
                bestMixedCellCount = recursiveResult.count;
                
                // 计算剩余空间 - 这是一个近似值，因为复杂混合摆放的剩余空间计算较复杂
                const totalVolume = caseLength * caseWidth * caseHeight;
                let usedVolume = 0;
                
                recursiveResult.arrangements.forEach(arr => {
                    const [dimX, dimY, dimZ] = arr.orientation.dims;
                    usedVolume += arr.count * dimX * dimY * dimZ;
                });
                
                bestMixedArrangement = {
                    cellCount: recursiveResult.count,
                    remainderVolume: totalVolume - usedVolume,
                    utilization: (usedVolume / totalVolume * 100).toFixed(2) + '%',
                    arrangements: recursiveResult.arrangements
                };
            }
            
            // 保留原有的按轴线分区策略代码，确保向后兼容
            // 尝试分区域策略 - 先尝试沿X轴分成两个区域
            for (let orientation1 of orientations) {
                const [dimX1, dimY1, dimZ1] = orientation1.dims;
                const countX1 = Math.floor(caseLength / dimX1);
                const countY1 = Math.floor(caseWidth / dimY1);
                const countZ1 = Math.floor(caseHeight / dimZ1);
                const usedX1 = countX1 * dimX1;
                
                // 如果X方向仍有剩余空间，尝试用另一种方向填充
                if (usedX1 < caseLength) {
                    const remainingX = caseLength - usedX1;
                    
                    for (let orientation2 of orientations) {
                        const [dimX2, dimY2, dimZ2] = orientation2.dims;
                        const countX2 = Math.floor(remainingX / dimX2);
                        
                        // 确保第二个方向有足够空间放置至少一个电芯
                        if (countX2 > 0) {
                            const countY2 = Math.floor(caseWidth / dimY2);
                            const countZ2 = Math.floor(caseHeight / dimZ2);
                            
                            const count1 = countX1 * countY1 * countZ1;
                            const count2 = countX2 * countY2 * countZ2;
                            const totalCount = count1 + count2;
                            
                            if (totalCount > bestMixedCellCount) {
                                bestMixedCellCount = totalCount;
                                
                                // 计算剩余空间
                                const usedX2 = countX2 * dimX2;
                                const totalUsedX = usedX1 + usedX2;
                                const remainderX = caseLength - totalUsedX;
                                
                                const usedY1 = countY1 * dimY1;
                                const remainderY1 = caseWidth - usedY1;
                                
                                const usedZ1 = countZ1 * dimZ1;
                                const remainderZ1 = caseHeight - usedZ1;
                                
                                bestMixedArrangement = {
                                    cellCount: totalCount,
                                    remainderX: remainderX,
                                    remainderY: Math.min(remainderY1, caseWidth - countY2 * dimY2),
                                    remainderZ: Math.min(remainderZ1, caseHeight - countZ2 * dimZ2),
                                    arrangements: [
                                        {
                                            orientation: orientation1,
                                            count: count1,
                                            countX: countX1,
                                            countY: countY1,
                                            countZ: countZ1,
                                            region: {
                                                x: [0, usedX1],
                                                y: [0, caseWidth],
                                                z: [0, caseHeight]
                                            }
                                        },
                                        {
                                            orientation: orientation2,
                                            count: count2,
                                            countX: countX2,
                                            countY: countY2,
                                            countZ: countZ2,
                                            region: {
                                                x: [usedX1, usedX1 + usedX2],
                                                y: [0, caseWidth],
                                                z: [0, caseHeight]
                                            }
                                        }
                                    ]
                                };
                            }
                        }
                    }
                }
            }
            
            // 尝试沿Y轴分成两个区域
            for (let orientation1 of orientations) {
                const [dimX1, dimY1, dimZ1] = orientation1.dims;
                const countX1 = Math.floor(caseLength / dimX1);
                const countY1 = Math.floor(caseWidth / dimY1);
                const countZ1 = Math.floor(caseHeight / dimZ1);
                const usedY1 = countY1 * dimY1;
                
                // 如果Y方向仍有剩余空间，尝试用另一种方向填充
                if (usedY1 < caseWidth) {
                    const remainingY = caseWidth - usedY1;
                    
                    for (let orientation2 of orientations) {
                        const [dimX2, dimY2, dimZ2] = orientation2.dims;
                        const countY2 = Math.floor(remainingY / dimY2);
                        
                        // 确保第二个方向有足够空间放置至少一个电芯
                        if (countY2 > 0) {
                            const countX2 = Math.floor(caseLength / dimX2);
                            const countZ2 = Math.floor(caseHeight / dimZ2);
                            
                            const count1 = countX1 * countY1 * countZ1;
                            const count2 = countX2 * countY2 * countZ2;
                            const totalCount = count1 + count2;
                            
                            if (totalCount > bestMixedCellCount) {
                                bestMixedCellCount = totalCount;
                                
                                // 计算剩余空间
                                const usedY2 = countY2 * dimY2;
                                const totalUsedY = usedY1 + usedY2;
                                const remainderY = caseWidth - totalUsedY;
                                
                                const usedX1 = countX1 * dimX1;
                                const remainderX1 = caseLength - usedX1;
                                
                                const usedZ1 = countZ1 * dimZ1;
                                const remainderZ1 = caseHeight - usedZ1;
                                
                                bestMixedArrangement = {
                                    cellCount: totalCount,
                                    remainderX: Math.min(remainderX1, caseLength - countX2 * dimX2),
                                    remainderY: remainderY,
                                    remainderZ: Math.min(remainderZ1, caseHeight - countZ2 * dimZ2),
                                    arrangements: [
                                        {
                                            orientation: orientation1,
                                            count: count1,
                                            countX: countX1,
                                            countY: countY1,
                                            countZ: countZ1,
                                            region: {
                                                x: [0, caseLength],
                                                y: [0, usedY1],
                                                z: [0, caseHeight]
                                            }
                                        },
                                        {
                                            orientation: orientation2,
                                            count: count2,
                                            countX: countX2,
                                            countY: countY2,
                                            countZ: countZ2,
                                            region: {
                                                x: [0, caseLength],
                                                y: [usedY1, usedY1 + usedY2],
                                                z: [0, caseHeight]
                                            }
                                        }
                                    ]
                                };
                            }
                        }
                    }
                }
            }
            
            // 尝试沿Z轴分成两个区域
            for (let orientation1 of orientations) {
                const [dimX1, dimY1, dimZ1] = orientation1.dims;
                const countX1 = Math.floor(caseLength / dimX1);
                const countY1 = Math.floor(caseWidth / dimY1);
                const countZ1 = Math.floor(caseHeight / dimZ1);
                const usedZ1 = countZ1 * dimZ1;
                
                // 如果Z方向仍有剩余空间，尝试用另一种方向填充
                if (usedZ1 < caseHeight) {
                    const remainingZ = caseHeight - usedZ1;
                    
                    for (let orientation2 of orientations) {
                        const [dimX2, dimY2, dimZ2] = orientation2.dims;
                        const countZ2 = Math.floor(remainingZ / dimZ2);
                        
                        // 确保第二个方向有足够空间放置至少一个电芯
                        if (countZ2 > 0) {
                            const countX2 = Math.floor(caseLength / dimX2);
                            const countY2 = Math.floor(caseWidth / dimY2);
                            
                            const count1 = countX1 * countY1 * countZ1;
                            const count2 = countX2 * countY2 * countZ2;
                            const totalCount = count1 + count2;
                            
                            if (totalCount > bestMixedCellCount) {
                                bestMixedCellCount = totalCount;
                                
                                // 计算剩余空间
                                const usedZ2 = countZ2 * dimZ2;
                                const totalUsedZ = usedZ1 + usedZ2;
                                const remainderZ = caseHeight - totalUsedZ;
                                
                                const usedX1 = countX1 * dimX1;
                                const remainderX1 = caseLength - usedX1;
                                
                                const usedY1 = countY1 * dimY1;
                                const remainderY1 = caseWidth - usedY1;
                                
                                bestMixedArrangement = {
                                    cellCount: totalCount,
                                    remainderX: Math.min(remainderX1, caseLength - countX2 * dimX2),
                                    remainderY: Math.min(remainderY1, caseWidth - countY2 * dimY2),
                                    remainderZ: remainderZ,
                                    arrangements: [
                                        {
                                            orientation: orientation1,
                                            count: count1,
                                            countX: countX1,
                                            countY: countY1,
                                            countZ: countZ1,
                                            region: {
                                                x: [0, caseLength],
                                                y: [0, caseWidth],
                                                z: [0, usedZ1]
                                            }
                                        },
                                        {
                                            orientation: orientation2,
                                            count: count2,
                                            countX: countX2,
                                            countY: countY2,
                                            countZ: countZ2,
                                            region: {
                                                x: [0, caseLength],
                                                y: [0, caseWidth],
                                                z: [usedZ1, usedZ1 + usedZ2]
                                            }
                                        }
                                    ]
                                };
                            }
                        }
                    }
                }
            }
            
            return bestMixedArrangement;
        }
        
        // 绘制混合摆放的示意图
        function drawMixedDiagram(arrangement, caseLength, caseWidth, caseHeight, cellLength, cellWidth, cellHeight) {
            console.log('绘制混合摆放示意图');
            
            // 由于混合摆放示意图比较复杂，这里先使用第一种摆放方式的参数绘制
            // 后续可以改进以更好地展示混合摆放
            const firstArrangement = arrangement.arrangements[0];
            
            drawDiagram(
                firstArrangement.countX,
                firstArrangement.countY,
                firstArrangement.countZ,
                firstArrangement.orientation.dims[0],
                firstArrangement.orientation.dims[1],
                firstArrangement.orientation.dims[2],
                "混合摆放 - " + firstArrangement.orientation.name
            );
            
            // 可以在这里添加额外的混合摆放图示，比如多区域显示等
            setupRotatable3DMixedView(arrangement, caseLength, caseWidth, caseHeight, cellLength, cellWidth, cellHeight);
        }
        
        // 为混合摆放创建3D视图
        function setupRotatable3DMixedView(mixedArrangement, caseLength, caseWidth, caseHeight, cellLength, cellWidth, cellHeight) {
            console.log('设置混合摆放3D视图', mixedArrangement);
            
            // 获取或创建3D容器
            let container = document.getElementById('3d-container');
            if (container) {
                // 清除现有内容
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            } else {
                container = document.createElement('div');
                container.id = '3d-container';
                container.style.width = '100%';
                container.style.height = '650px'; // 原来是500px，改为650px
                container.style.marginTop = '20px';
                container.style.marginBottom = '30px';
                container.style.overflow = 'hidden';
                container.style.position = 'relative';
                container.style.borderRadius = '10px';
                container.style.boxShadow = '0 4px 20px rgba(0,0,0,0.08)';
                
                // 添加到结果区域
                const resultDiv = document.getElementById('result');
                if (!resultDiv) {
                    console.error('找不到结果容器');
                    return;
                }
                resultDiv.appendChild(container);
            }
            
            // 添加标题
            const title = document.createElement('h3');
            title.textContent = '';
            title.style.fontSize = '18px';
            title.style.fontWeight = '600';
            title.style.margin = '15px';
            title.style.color = '#1d1d1f';
            title.style.position = 'absolute';
            title.style.top = '0';
            title.style.left = '0';
            title.setAttribute('data-title', '3d-view');
            container.appendChild(title);
            
            // 添加提示信息
            const instructions = document.createElement('div');
            instructions.id = 'diagram-instructions';
            instructions.style.position = 'absolute';
            instructions.style.bottom = '10px';
            instructions.style.right = '10px';
            instructions.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            instructions.style.padding = '5px 10px';
            instructions.style.borderRadius = '5px';
            instructions.style.fontSize = '12px';
            instructions.style.color = '#666';
            instructions.style.zIndex = '100';
            instructions.innerHTML = '拖动旋转视图，滚轮缩放';
            container.appendChild(instructions);
            
            // 创建Three.js场景
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f7);
            
            // 设置相机
            const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
            const maxDimension = Math.max(caseLength, caseWidth, caseHeight) * 2;
            camera.position.set(maxDimension, maxDimension, maxDimension);
            camera.lookAt(0, 0, 0);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(caseLength * 2, caseHeight * 2, caseWidth * 1.5);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-caseLength, -caseHeight / 2, -caseWidth);
            scene.add(directionalLight2);
            
            // 添加网格辅助线
            const gridSize = Math.max(caseLength, caseWidth) * 2; // 增大网格大小为原来的2倍
            const gridHelper = new THREE.GridHelper(gridSize, 40, 0x888888, 0xdddddd); // 增加网格线数量，40×40
            // 将网格中心定位在坐标系原点(0,0,0)，使网格线从0开始
            gridHelper.position.set(0, -0.5, 0);
            scene.add(gridHelper);
            
            // 创建渲染器
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // 添加轨道控制
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // 创建外壳
            const caseGeometry = new THREE.BoxGeometry(caseLength, caseHeight, caseWidth);
            const caseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xdddddd, 
                transparent: true, 
                opacity: 0.3,
                wireframe: false,
                side: THREE.DoubleSide
            });
            const caseOutline = new THREE.LineSegments(
                new THREE.EdgesGeometry(caseGeometry),
                new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 1 })
            );
            
            // 修改caseMesh的位置，使其从坐标(0,0,0)开始放置，而不是中心对齐
            const caseMesh = new THREE.Mesh(caseGeometry, caseMaterial);
            caseMesh.position.set(caseLength/2, caseHeight/2, caseWidth/2);
            caseOutline.position.copy(caseMesh.position);
            scene.add(caseMesh);
            scene.add(caseOutline);
            
            // 根据排列方式分配不同颜色 - 使用清晰区分的颜色
            const colorPalette = [
                0x3388dd, // 蓝色
                0xff6644, // 红色
                0x66cc66, // 绿色
                0xffcc44, // 黄色
                0x9966cc, // 紫色
                0x66cccc  // 青色
            ];
            
            // 为每个区域创建电芯
            mixedArrangement.arrangements.forEach((arrangement, arrangementIndex) => {
                const [dimX, dimY, dimZ] = arrangement.orientation.dims;
                const colorIndex = arrangementIndex % colorPalette.length;
                const cellColor = colorPalette[colorIndex];
                
                // 创建电芯几何体
                const cellGeometry = new THREE.BoxGeometry(dimX, dimZ, dimY); // 注意XYZ轴的映射
                const cellMaterial = new THREE.MeshStandardMaterial({ 
                    color: cellColor,
                    metalness: 0.1,
                    roughness: 0.5
                });
                
                // 获取当前区域的信息
                const region = arrangement.region;
                const startX = region.x[0];
                const startY = region.y[0];
                const startZ = region.z[0];
                
                // 遍历并创建电芯
                for (let x = 0; x < arrangement.countX; x++) {
                    for (let y = 0; y < arrangement.countY; y++) {
                        for (let z = 0; z < arrangement.countZ; z++) {
                            const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                            
                            // 计算电芯位置 - 考虑区域的起始坐标
                            const posX = startX + x * dimX + dimX / 2;
                            const posY = startZ + z * dimZ + dimZ / 2; // Z轴映射到Y轴
                            const posZ = startY + y * dimY + dimY / 2; // Y轴映射到Z轴
                            
                            cell.position.set(posX, posY, posZ);
                            
                            // 为电芯添加描边
                            const cellOutline = new THREE.LineSegments(
                                new THREE.EdgesGeometry(cellGeometry),
                                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 0.5 })
                            );
                            cellOutline.position.copy(cell.position);
                            
                            scene.add(cell);
                            scene.add(cellOutline);
                        }
                    }
                }
                
                // 为当前区域添加边框，更清晰地显示不同区域
                const regionWidth = region.x[1] - region.x[0];
                const regionHeight = region.z[1] - region.z[0];
                const regionDepth = region.y[1] - region.y[0];
                
                const regionGeometry = new THREE.BoxGeometry(regionWidth, regionHeight, regionDepth);
                const regionMaterial = new THREE.MeshBasicMaterial({
                    color: cellColor,
                    transparent: true,
                    opacity: 0.15,
                    wireframe: false
                });
                
                const regionOutline = new THREE.LineSegments(
                    new THREE.EdgesGeometry(regionGeometry),
                    new THREE.LineBasicMaterial({ color: cellColor, linewidth: 2 })
                );
                
                const regionMesh = new THREE.Mesh(regionGeometry, regionMaterial);
                regionMesh.position.set(
                    startX + regionWidth / 2,
                    startZ + regionHeight / 2,
                    startY + regionDepth / 2
                );
                regionOutline.position.copy(regionMesh.position);
                
                scene.add(regionMesh);
                scene.add(regionOutline);
            });
            
            // 添加坐标轴辅助
            const axesHelper = new THREE.AxesHelper(Math.max(caseLength, caseWidth, caseHeight) * 1.2);
            scene.add(axesHelper);
            
            // 添加坐标轴刻度和尺寸标注
            function createAxisWithTicks(start, end, length, tickCount, color, labelText) {
                const tickGroup = new THREE.Group();
                
                // 创建主轴线
                const mainAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...start),
                    new THREE.Vector3(...end)
                ]);
                const mainAxisMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
                const mainAxis = new THREE.Line(mainAxisGeometry, mainAxisMaterial);
                tickGroup.add(mainAxis);
                
                // 创建与轴平行的尺子背景
                const rulerWidth = Math.min(caseLength, caseWidth, caseHeight) * 0.05; // 尺子宽度
                const rulerLength = length;
                let rulerGeometry, rulerPosition;
                
                if (start[0] !== end[0]) { // X轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerLength, rulerWidth);
                    rulerPosition = [start[0] + rulerLength/2, start[1] - rulerWidth/2, start[2]];
                    rulerGeometry.rotateX(-Math.PI/2);
                } else if (start[1] !== end[1]) { // Y轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0] - rulerWidth/2, start[1] + rulerLength/2, start[2]];
                    rulerGeometry.rotateZ(Math.PI/2);
                } else { // Z轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0], start[1] - rulerWidth/2, start[2] + rulerLength/2];
                    rulerGeometry.rotateY(Math.PI/2);
                }
                
                // 创建半透明尺子背景材质
                const rulerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                
                const ruler = new THREE.Mesh(rulerGeometry, rulerMaterial);
                ruler.position.set(...rulerPosition);
                tickGroup.add(ruler);
                
                // 为轴添加刻度线和数值标签
                const tickStep = length / tickCount;
                const majorTickSize = Math.min(caseLength, caseWidth, caseHeight) * 0.04; // 主刻度线大小
                const minorTickSize = majorTickSize * 0.6; // 次刻度线大小
                
                for (let i = 0; i <= tickCount * 5; i++) {
                    // 确定刻度线位置 (包括5个小刻度)
                    const pos = i * (tickStep / 5);
                    const isMajorTick = i % 5 === 0; // 每5个刻度一个主刻度
                    const tickSize = isMajorTick ? majorTickSize : minorTickSize;
                    let tickStart, tickEnd;
                    
                    if (start[0] !== end[0]) { // X轴
                        tickStart = [start[0] + pos, start[1], start[2]];
                        tickEnd = [start[0] + pos, start[1] - tickSize, start[2]];
                    } else if (start[1] !== end[1]) { // Y轴
                        tickStart = [start[0], start[1] + pos, start[2]];
                        tickEnd = [start[0] - tickSize, start[1] + pos, start[2]];
                    } else { // Z轴
                        tickStart = [start[0], start[1], start[2] + pos];
                        tickEnd = [start[0], start[1] - tickSize, start[2] + pos];
                    }
                    
                    // 创建刻度线材质 - 主刻度线更粗更明显
                    const tickMaterial = new THREE.LineBasicMaterial({ 
                        color: color, 
                        linewidth: isMajorTick ? 2 : 1,
                        opacity: isMajorTick ? 1 : 0.7,
                        transparent: true
                    });
                    
                    // 创建刻度线
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...tickStart),
                        new THREE.Vector3(...tickEnd)
                    ]);
                    const tickLine = new THREE.Line(tickGeometry, tickMaterial);
                    tickGroup.add(tickLine);
                    
                    // 只为主刻度添加数值标签
                    if (isMajorTick) {
                        const tickValue = Math.round(pos * 10) / 10; // 保留一位小数
                        
                        // 确定标签位置
                        let labelPos;
                        if (start[0] !== end[0]) { // X轴
                            labelPos = [start[0] + pos, start[1] - tickSize * 1.5, start[2]];
                        } else if (start[1] !== end[1]) { // Y轴
                            labelPos = [start[0] - tickSize * 1.5, start[1] + pos, start[2]];
                        } else { // Z轴
                            labelPos = [start[0], start[1] - tickSize * 1.5, start[2] + pos];
                        }
                        
                        // 创建文字精灵
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 64;
                        canvas.height = 32;
                        
                        // 设置文字样式 - 透明背景
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.font = 'Bold 20px Arial';
                        context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(`${tickValue}`, canvas.width / 2, canvas.height / 2);
                        
                        // 创建纹理
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;
                        
                        // 创建精灵材质 - 透明背景
                        const spriteMaterial = new THREE.SpriteMaterial({ 
                            map: texture,
                            transparent: true
                        });
                        
                        // 创建精灵
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(...labelPos);
                        
                        // 根据物体尺寸调整标签大小
                        const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                        sprite.scale.set(maxDim * 0.04, maxDim * 0.02, 1);
                        
                        tickGroup.add(sprite);
                    }
                }
                
                // 添加轴标签 (例如 "X轴: 30厘米")
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 64;
                
                // 设置文字样式 - 透明背景
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 24px Arial';
                context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`${labelText}: ${length}厘米`, canvas.width / 2, canvas.height / 2);
                
                // 创建纹理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 创建精灵材质 - 透明背景
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true 
                });
                
                // 创建精灵并放置在轴末端之外
                const sprite = new THREE.Sprite(spriteMaterial);
                let labelPosition;
                
                if (start[0] !== end[0]) { // X轴
                    labelPosition = [end[0] + length * 0.05, end[1], end[2]];
                } else if (start[1] !== end[1]) { // Y轴
                    labelPosition = [end[0], end[1] + length * 0.05, end[2]];
                } else { // Z轴
                    labelPosition = [end[0], end[1], end[2] + length * 0.05];
                }
                
                sprite.position.set(...labelPosition);
                
                // 根据物体尺寸调整标签大小
                const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                sprite.scale.set(maxDim * 0.2, maxDim * 0.06, 1);
                
                tickGroup.add(sprite);
                
                scene.add(tickGroup);
                return tickGroup;
            }
            
            // 创建各轴刻度和尺寸标注
            const xAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [caseLength, 0, 0], 
                caseLength, 
                10, // 分10个刻度
                0xff0000, 
                "X轴"
            );
            
            const yAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, caseHeight, 0], 
                caseHeight, 
                10, // 分10个刻度
                0x00ff00, 
                "Y轴"
            );
            
            const zAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, 0, caseWidth], 
                caseWidth, 
                10, // 分10个刻度
                0x0000ff, 
                "Z轴"
            );
            
            // 添加坐标轴标签
            const xAxisLabel = document.createElement('div');
            xAxisLabel.className = 'axis-label';
            xAxisLabel.textContent = 'X轴';
            xAxisLabel.style.position = 'absolute';
            xAxisLabel.style.color = '#ff0000';
            xAxisLabel.style.fontSize = '14px';
            xAxisLabel.style.fontWeight = 'bold';
            xAxisLabel.style.backgroundColor = 'rgba(255,255,255,0.8)';
            xAxisLabel.style.padding = '3px 6px';
            xAxisLabel.style.borderRadius = '4px';
            xAxisLabel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            xAxisLabel.style.zIndex = '1000';
            container.appendChild(xAxisLabel);

            const yAxisLabel = document.createElement('div');
            yAxisLabel.className = 'axis-label';
            yAxisLabel.textContent = 'Y轴';
            yAxisLabel.style.position = 'absolute';
            yAxisLabel.style.color = '#00ff00';
            yAxisLabel.style.fontSize = '14px';
            yAxisLabel.style.fontWeight = 'bold';
            yAxisLabel.style.backgroundColor = 'rgba(255,255,255,0.8)';
            yAxisLabel.style.padding = '3px 6px';
            yAxisLabel.style.borderRadius = '4px';
            yAxisLabel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            yAxisLabel.style.zIndex = '1000';
            container.appendChild(yAxisLabel);

            const zAxisLabel = document.createElement('div');
            zAxisLabel.className = 'axis-label';
            zAxisLabel.textContent = 'Z轴';
            zAxisLabel.style.position = 'absolute';
            zAxisLabel.style.color = '#0000ff';
            zAxisLabel.style.fontSize = '14px';
            zAxisLabel.style.fontWeight = 'bold';
            zAxisLabel.style.backgroundColor = 'rgba(255,255,255,0.8)';
            zAxisLabel.style.padding = '3px 6px';
            zAxisLabel.style.borderRadius = '4px';
            zAxisLabel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            zAxisLabel.style.zIndex = '1000';
            container.appendChild(zAxisLabel);
            
            // 添加3D文字标签显示不同区域信息
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                mixedArrangement.arrangements.forEach((arrangement, index) => {
                    const region = arrangement.region;
                    const centerX = (region.x[0] + region.x[1]) / 2;
                    const centerY = (region.z[0] + region.z[1]) / 2 + region.z[1] * 0.1; // 文字稍微高一点
                    const centerZ = (region.y[0] + region.y[1]) / 2;
                    
                    // 创建区域标签
                    const textGeometry = new THREE.TextGeometry(`区域 ${index+1}`, {
                        font: font,
                        size: Math.min(caseLength, caseWidth, caseHeight) * 0.05,
                        height: 0.1
                    });
                    
                    textGeometry.computeBoundingBox();
                    const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                    
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // 定位在区域上方中央
                    textMesh.position.set(centerX - textWidth / 2, centerY, centerZ);
                    scene.add(textMesh);
                });
            });
            
            // 渲染函数
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                
                // 更新坐标轴标签位置
                updateAxisLabels();
                
                renderer.render(scene, camera);
            }
            
            // 更新坐标轴标签位置
            function updateAxisLabels() {
                // 定义轴的末端点
                const axisLength = Math.max(caseLength, caseWidth, caseHeight) * 1.2;
                const axes = [
                    { end: new THREE.Vector3(axisLength, 0, 0), label: xAxisLabel },
                    { end: new THREE.Vector3(0, axisLength, 0), label: yAxisLabel },
                    { end: new THREE.Vector3(0, 0, axisLength), label: zAxisLabel }
                ];
                
                // 计算二维坐标
                axes.forEach(axis => {
                    const vector = axis.end.clone();
                    vector.project(camera);
                    
                    // 将归一化的设备坐标(NDC)转换为屏幕坐标
                    const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * container.clientHeight;
                    
                    // 更新标签位置
                    axis.label.style.left = x + 'px';
                    axis.label.style.top = y + 'px';
                });
            }
            
            // 开始渲染
            animate();
            
            // 添加重置相机位置功能
            function resetCameraPosition() {
                // 计算需要的相机距离以显示整个外壳
                const maxDimension = Math.max(caseLength, caseWidth, caseHeight);
                // 设置距离使视图显示更大，确保满屏视角
                const distance = maxDimension * 2.0;
                
                // 设置相机位置
                camera.position.set(
                    caseLength/2 + distance * 0.8, 
                    caseHeight/2 + distance * 0.6, 
                    caseWidth/2 + distance * 0.8
                );
                
                // 看向外壳中心
                camera.lookAt(caseLength/2, caseHeight/2, caseWidth/2);
                
                // 更新控制器
                controls.target.set(caseLength/2, caseHeight/2, caseWidth/2);
                controls.update();
            }
            
            // 初始化相机位置以显示全貌
            resetCameraPosition();
            
            // 添加重置视图按钮
            const resetButton = document.createElement('button');
            resetButton.style.position = 'absolute';
            resetButton.style.top = '10px';
            resetButton.style.right = '10px';
            resetButton.style.padding = '8px 12px';
            resetButton.style.backgroundColor = '#0071e3';
            resetButton.style.color = '#ffffff';
            resetButton.style.border = 'none';
            resetButton.style.borderRadius = '8px';
            resetButton.style.fontSize = '14px';
            resetButton.style.fontWeight = '500';
            resetButton.style.cursor = 'pointer';
            resetButton.style.zIndex = '100';
            resetButton.textContent = '重置视图';
            resetButton.onclick = resetCameraPosition;
            container.appendChild(resetButton);
            
            // 添加窗口调整大小的监听
            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function drawDiagram(lengthCount, widthCount, heightCount, cellX, cellY, cellZ, arrangementName) {
            console.log('进入drawDiagram函数');
            
            // 获取实际尺寸
            const caseLength = Number(document.getElementById('case-length').value);
            const caseWidth = Number(document.getElementById('case-width').value);
            const caseHeight = Number(document.getElementById('case-height').value);
            const cellLength = Number(document.getElementById('cell-length').value);
            const cellWidth = Number(document.getElementById('cell-width').value);
            const cellHeight = Number(document.getElementById('cell-height').value);

            // 计算剩余空间
            const remainderLength = Number(caseLength - lengthCount * cellX).toFixed(1);
            const remainderWidth = Number(caseWidth - widthCount * cellY).toFixed(1);
            const remainderHeight = Number(caseHeight - heightCount * cellZ).toFixed(1);

            // 直接创建3D可旋转模型，不再绘制三视图
            setupRotatable3DView(lengthCount, widthCount, heightCount, cellX, cellY, cellZ, caseLength, caseWidth, caseHeight, arrangementName);
        }

        function setupRotatable3DView(lengthCount, widthCount, heightCount, cellX, cellY, cellZ, caseLength, caseWidth, caseHeight, arrangementName) {
            try {
                console.log('设置3D视图，参数：', {
                    lengthCount, widthCount, heightCount, 
                    cellX, cellY, cellZ, 
                    caseLength, caseWidth, caseHeight
                });
                
                // 检查Three.js是否加载
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js未加载');
                }
                
                // 添加等待OrbitControls加载的逻辑
                function setupScene() {
                    // 确保引用电芯尺寸
                    const cellLength = Number(document.getElementById('cell-length').value);
                    const cellWidth = Number(document.getElementById('cell-width').value);
                    const cellHeight = Number(document.getElementById('cell-height').value);
                    
                    // 添加一个调试信息到控制台，检查实际渲染的电芯数量是否与计算结果一致
                    console.log('应该渲染的电芯数量：', lengthCount * widthCount * heightCount);
                    console.log('电芯排列方式：', `${lengthCount} × ${widthCount} × ${heightCount} (${arrangementName})`);
                    
                    // 更全面地移除所有可能的3D相关元素
                    function removeAll3DElements() {
                        // 移除所有3D标题
                        document.querySelectorAll('h3').forEach(el => {
                            if (el.textContent.includes('3D视图') || 
                                el.getAttribute('data-title') === '3d-view' ||
                                el.textContent.includes('加载失败')) {
                                console.log('移除3D标题:', el.textContent);
                                el.remove();
                            }
                        });
                        
                        // 移除所有可能的3D容器
                        document.querySelectorAll('[id^="3d-container"], [id="3d-diagram"]').forEach(el => {
                            console.log('移除3D容器:', el.id);
                            el.remove();
                        });
                        
                        // 移除其他可能存在的元素
                        const elementsToRemove = document.querySelectorAll(
                            '#diagram-info, #diagram-instructions, #total-text, #size-info, ' +
                            '#digital-info-container, [class*="3d"], [id*="3d"]'
                        );
                        elementsToRemove.forEach(el => el.remove());
                    }
                    
                    // 执行清理
                    removeAll3DElements();
                    
                    // 创建新的数字结果区域
                    const infoContainer = document.createElement('div');
                    infoContainer.id = 'digital-info-container';
                    infoContainer.style.width = '100%';
                    infoContainer.style.maxWidth = isMobile ? '100%' : '600px';
                    infoContainer.style.margin = '20px auto';
                    infoContainer.style.padding = isMobile ? '15px 10px' : '20px';
                    infoContainer.style.backgroundColor = '#f5f5f7';
                    infoContainer.style.borderRadius = '12px';
                    infoContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.05)';
                    infoContainer.style.fontFamily = '-apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif';
                    infoContainer.style.fontSize = isMobile ? '14px' : '15px';
                    infoContainer.style.overflowX = isMobile ? 'auto' : 'visible';
                    
                    // 添加标题
                    const title = document.createElement('h3');
                    title.textContent = '';
                    title.style.fontSize = '18px';
                    title.style.fontWeight = '600';
                    title.style.marginBottom = '15px';
                    title.style.color = '#1d1d1f';
                    infoContainer.appendChild(title);
                    
                    // 添加到页面
                    const resultDiv = document.getElementById('result');
                    resultDiv.appendChild(infoContainer);
                    
                    // 如果是iOS，可能需要避免使用WebGL或降级处理
                    if (isIOS) {
                        console.log('检测到iOS设备，使用降级处理');
                        
                        // 创建3D视图标题但添加警告
                        const threeDTitle = document.createElement('h3');
                        threeDTitle.textContent = '3D视图 (iOS兼容模式)';
                        threeDTitle.setAttribute('data-title', '3d-view');
                        threeDTitle.style.fontSize = isMobile ? '16px' : '18px';
                        threeDTitle.style.fontWeight = '600';
                        threeDTitle.style.margin = '30px 0 15px 0';
                        threeDTitle.style.color = '#1d1d1f';
                        
                        // 创建简化的容器
                        const threeDContainer = document.createElement('div');
                        threeDContainer.id = '3d-container';
                        threeDContainer.style.width = '100%';
                        threeDContainer.style.maxWidth = isMobile ? '100%' : '600px';
                        threeDContainer.style.height = isMobile ? '450px' : '650px'; // 从350px/400px改为450px/650px
                        threeDContainer.style.margin = '0 auto 30px auto';
                        threeDContainer.style.position = 'relative';
                        threeDContainer.style.backgroundColor = '#f5f5f7';
                        threeDContainer.style.borderRadius = '12px';
                        threeDContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.05)';
                        threeDContainer.style.display = 'flex';
                        threeDContainer.style.alignItems = 'center';
                        threeDContainer.style.justifyContent = 'center';
                        threeDContainer.style.flexDirection = 'column';
                        threeDContainer.style.padding = '20px';
                        threeDContainer.style.textAlign = 'center';
                        
                        // 添加信息提示
                        threeDContainer.innerHTML = `
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 15px;">电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</div>
                            <div style="font-size: 14px; color: #86868b; margin-bottom: 15px;">电芯尺寸: ${cellX}×${cellY}×${cellZ} 厘米</div>
                            <div style="font-size: 14px; color: #86868b; margin-bottom: 15px;">外壳尺寸: ${caseLength}×${caseWidth}×${caseHeight} 厘米</div>
                            <div style="background-color: #ffefef; padding: 15px; border-radius: 8px; max-width: 90%;">
                                <p style="margin: 0; color: #d0000f; font-size: 14px;">iOS设备目前暂不支持3D视图。</p>
                                <p style="margin: 5px 0 0; color: #d0000f; font-size: 14px;">请参考上方三视图查看排列情况。</p>
                            </div>
                        `;
                        
                        // 添加到页面
                        resultDiv.appendChild(threeDTitle);
                        resultDiv.appendChild(threeDContainer);
                        
                        return; // 不继续执行Three.js相关代码
                    }
                    
                    // 创建3D视图标题
                    const threeDTitle = document.createElement('h3');
                    threeDTitle.textContent = '3D视图';
                    threeDTitle.setAttribute('data-title', '3d-view');
                    threeDTitle.style.fontSize = isMobile ? '16px' : '18px';
                    threeDTitle.style.fontWeight = '600';
                    threeDTitle.style.margin = '30px 0 15px 0';
                    threeDTitle.style.color = '#1d1d1f';
                    
                    // 创建3D容器
                    const threeDContainer = document.createElement('div');
                    threeDContainer.id = '3d-container';
                    threeDContainer.style.width = '100%';
                    threeDContainer.style.maxWidth = isMobile ? '100%' : '600px';
                    threeDContainer.style.height = isMobile ? '450px' : '650px'; // 从350px/400px改为450px/650px
                    threeDContainer.style.margin = '0 auto 30px auto';
                    threeDContainer.style.position = 'relative';
                    threeDContainer.style.backgroundColor = '#ffffff';
                    threeDContainer.style.borderRadius = '12px';
                    threeDContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.05)';
                    threeDContainer.style.overflow = 'hidden';
                    
                    // 添加3D视图说明
                    const threeDInfo = document.createElement('div');
                    threeDInfo.style.position = 'absolute';
                    threeDInfo.style.bottom = '10px';
                    threeDInfo.style.left = '10px';
                    threeDInfo.style.backgroundColor = 'rgba(255,255,255,0.7)';
                    threeDInfo.style.padding = '6px 10px';
                    threeDInfo.style.borderRadius = '8px';
                    threeDInfo.style.fontSize = isMobile ? '11px' : '12px';
                    threeDInfo.style.color = '#1d1d1f';
                    threeDInfo.innerHTML = `
                        <div>拖动可旋转查看 • 滚轮可缩放</div>
                        <div>电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</div>
                    `;
                    
                    // 创建3D画布
                    const threeDCanvas = document.createElement('canvas');
                    threeDCanvas.id = '3d-diagram';
                    threeDCanvas.width = isMobile ? window.innerWidth - 30 : 600;
                    threeDCanvas.height = isMobile ? 450 : 650; // 更新高度与容器一致
                    threeDCanvas.style.width = '100%';
                    threeDCanvas.style.height = '100%';
                    
                    // 添加到容器
                    threeDContainer.appendChild(threeDCanvas);
                    threeDContainer.appendChild(threeDInfo);
                    
                    // 添加到页面
                    resultDiv.appendChild(threeDTitle);
                    resultDiv.appendChild(threeDContainer);
                    
                    // 检查THREE和OrbitControls是否可用
                    if (typeof THREE === 'undefined') {
                        showErrorView(threeDContainer, 'THREE未定义，无法加载3D视图');
                        return;
                    }
                    
                    if (typeof THREE.OrbitControls === 'undefined') {
                        showErrorView(threeDContainer, 'OrbitControls未定义，无法加载可旋转3D视图');
                        return;
                    }
                    
                    // 创建Three.js场景
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0xf5f5f7);
                    
                    // 设置相机
                    const camera = new THREE.PerspectiveCamera(50, threeDCanvas.width / threeDCanvas.height, 0.1, 1000);
                    camera.position.set(lengthCount * 2, heightCount * 3, widthCount * 3);
                    camera.lookAt(lengthCount/2, heightCount/2, widthCount/2);
                    
                    // 设置渲染器
                    const renderer = new THREE.WebGLRenderer({ canvas: threeDCanvas, antialias: true });
                    renderer.setSize(threeDCanvas.width, threeDCanvas.height);
                    
                    // 添加轨道控制
                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    
                    // 添加环境光和定向光
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(lengthCount*2, heightCount*4, widthCount*2);
                    scene.add(directionalLight);
                    
                    // 这里是现有的Three.js 3D视图创建代码
                    // ... 保持原有的3D视图创建代码不变
                    try {
                        // 创建电池壳体
                        const caseGeometry = new THREE.BoxGeometry(caseLength, caseHeight, caseWidth);
                        const caseMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x2196f3, 
                            transparent: true, 
                            opacity: 0.15
                        });
                        const caseMesh = new THREE.Mesh(caseGeometry, caseMaterial);
                        caseMesh.position.set(caseLength/2, caseHeight/2, caseWidth/2);
                        scene.add(caseMesh);
                        
                        // 添加网格辅助线
                        const gridSize = Math.max(caseLength, caseWidth) * 1.1; // 只比物体稍微大一点
                        const gridHelper = new THREE.GridHelper(gridSize, 20, 0x888888, 0xdddddd);
                        // 将网格中心定位在坐标系原点(0,0,0)，使网格线从0开始
                        gridHelper.position.set(0, -0.5, 0);
                        scene.add(gridHelper);
                        
                        // 其他原有代码...
                    } catch(e) {
                        console.error("渲染3D视图时出错:", e);
                        showErrorView(threeDContainer, e.message);
                    }
                }

                // 显示3D错误视图
                function showErrorView(container, errorMsg) {
                    container.style.display = 'flex';
                    container.style.alignItems = 'center';
                    container.style.justifyContent = 'center';
                    container.style.flexDirection = 'column';
                    container.style.padding = '20px';
                    container.style.backgroundColor = '#ffefef';
                    
                    container.innerHTML = `
                        <div style="font-size: 16px; font-weight: 600; color: #d0000f; margin-bottom: 15px;">3D视图加载失败</div>
                        <div style="text-align: center;">
                            <p style="margin: 0 0 10px 0;">原因: ${errorMsg}</p>
                            <p style="margin: 10px 0;">电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</p>
                            <p style="margin: 0 0 10px 0;">电芯尺寸: ${cellX}×${cellY}×${cellZ} 厘米</p>
                            <button id="retry-button" style="padding: 8px 15px; background-color: #0071e3; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 10px;">刷新页面</button>
                        </div>
                    `;
                    
                    // 添加重试按钮事件
                    setTimeout(() => {
                        const retryButton = document.getElementById('retry-button');
                        if (retryButton) {
                            retryButton.addEventListener('click', function() {
                                // 刷新页面
                                window.location.reload();
                            });
                        }
                    }, 100);
                }

                // 显示简单的静态3D视图（不使用OrbitControls）
                function showSimple3DView(container, lengthCount, widthCount, heightCount, cellX, cellY, cellZ, caseLength, caseWidth, caseHeight) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = container.clientWidth;
                        canvas.height = container.clientHeight;
                        container.innerHTML = '';
                        container.appendChild(canvas);
                        
                        // 创建简单的静态Three.js场景
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color(0xf5f5f7);
                        
                        const camera = new THREE.PerspectiveCamera(50, canvas.width / canvas.height, 0.1, 1000);
                        const maxDimension = Math.max(caseLength, caseWidth, caseHeight);
                        camera.position.set(maxDimension * 1.5, maxDimension * 1.5, maxDimension * 1.5);
                        camera.lookAt(caseLength/2, caseHeight/2, caseWidth/2);
                        
                        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                        renderer.setSize(canvas.width, canvas.height);
                        
                        // 添加光源
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                        scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(caseLength*2, caseHeight*2, caseWidth*2);
                        scene.add(directionalLight);
                        
                        // 创建外壳和电芯
                        const caseGeometry = new THREE.BoxGeometry(caseLength, caseHeight, caseWidth);
                        const caseMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x2196f3, 
                            transparent: true, 
                            opacity: 0.15
                        });
                        const caseMesh = new THREE.Mesh(caseGeometry, caseMaterial);
                        caseMesh.position.set(caseLength/2, caseHeight/2, caseWidth/2);
                        scene.add(caseMesh);
                        
                        // 添加边框
                        const edges = new THREE.EdgesGeometry(caseGeometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0071e3 }));
                        line.position.copy(caseMesh.position);
                        scene.add(line);
                        
                        // 添加网格辅助线
                        const gridSize = Math.max(caseLength, caseWidth) * 1.1; // 只比物体稍微大一点
                        const gridHelper = new THREE.GridHelper(gridSize, 20, 0x888888, 0xdddddd);
                        // 将网格中心定位在坐标系原点(0,0,0)，使网格线从0开始
                        gridHelper.position.set(0, -0.5, 0);
                        scene.add(gridHelper);
                        
                        // 创建电芯（仅绘制少量电芯，提高性能）
                        const maxCellsToRender = 100; // 限制渲染的电芯数量
                        const totalCells = lengthCount * widthCount * heightCount;
                        let renderAll = totalCells <= maxCellsToRender;
                        
                        // 如果电芯数量过多，仅渲染一部分
                        let skipFactor = renderAll ? 1 : Math.ceil(totalCells / maxCellsToRender);
                        
                        const cellGeometry = new THREE.BoxGeometry(cellX, cellZ, cellY);
                        const cellMaterial = new THREE.MeshPhongMaterial({ color: 0x4caf50 });
                        
                        for (let x = 0; x < lengthCount; x += (renderAll ? 1 : skipFactor)) {
                            for (let y = 0; y < heightCount; y += (renderAll ? 1 : skipFactor)) {
                                for (let z = 0; z < widthCount; z += (renderAll ? 1 : skipFactor)) {
                                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                                    cell.position.set(
                                        x * cellX + cellX/2,
                                        y * cellZ + cellZ/2,
                                        z * cellY + cellY/2
                                    );
                                    scene.add(cell);
                                }
                            }
                        }
                        
                        // 渲染静态视图
                        renderer.render(scene, camera);
                        
                        // 添加说明
                        const info = document.createElement('div');
                        info.style.position = 'absolute';
                        info.style.bottom = '10px';
                        info.style.left = '10px';
                        info.style.backgroundColor = 'rgba(255,255,255,0.7)';
                        info.style.padding = '6px 10px';
                        info.style.borderRadius = '8px';
                        info.style.fontSize = '12px';
                        info.style.color = '#1d1d1f';
                        info.innerHTML = `
                            <div>静态3D视图（OrbitControls未加载）</div>
                            <div>电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</div>
                        `;
                        container.appendChild(info);
                        
                        // 添加重试按钮
                        const retryButton = document.createElement('button');
                        retryButton.textContent = '刷新页面重试';
                        retryButton.style.position = 'absolute';
                        retryButton.style.top = '10px';
                        retryButton.style.right = '10px';
                        retryButton.style.padding = '8px 12px';
                        retryButton.style.backgroundColor = '#0071e3';
                        retryButton.style.color = '#ffffff';
                        retryButton.style.border = 'none';
                        retryButton.style.borderRadius = '8px';
                        retryButton.style.fontSize = '12px';
                        retryButton.style.cursor = 'pointer';
                        retryButton.onclick = function() {
                            // 刷新页面
                            window.location.reload();
                        };
                        container.appendChild(retryButton);
                        
                    } catch (error) {
                        console.error('创建简单3D视图时出错:', error);
                        showErrorView(container, error.message);
                    }
                }

                // 检查THREE.OrbitControls是否可用，如果可用直接设置场景，否则先加载OrbitControls
                if (typeof THREE !== 'undefined') {
                    if (typeof THREE.OrbitControls !== 'undefined') {
                        // OrbitControls已加载，直接设置场景
                        setupScene();
                    } else {
                        // OrbitControls未找到，显示错误
                        console.error('THREE.OrbitControls未定义，无法创建3D视图');
                        
                        const resultDiv = document.getElementById('result');
                        const errorTitle = document.createElement('h3');
                        errorTitle.textContent = '3D视图 (加载失败)';
                        errorTitle.style.fontSize = isMobile ? '16px' : '18px';
                        errorTitle.style.fontWeight = '600';
                        errorTitle.style.margin = '30px 0 15px 0';
                        errorTitle.style.color = '#1d1d1f';
                        
                        const errorContainer = document.createElement('div');
                        errorContainer.style.width = '100%';
                        errorContainer.style.maxWidth = isMobile ? '100%' : '600px';
                        errorContainer.style.height = isMobile ? '450px' : '650px'; // 更新错误容器高度
                        errorContainer.style.margin = '0 auto 30px auto';
                        errorContainer.style.backgroundColor = '#ffefef';
                        errorContainer.style.borderRadius = '12px';
                        errorContainer.style.display = 'flex';
                        errorContainer.style.alignItems = 'center';
                        errorContainer.style.justifyContent = 'center';
                        errorContainer.style.flexDirection = 'column';
                        errorContainer.style.padding = '20px';
                        errorContainer.style.textAlign = 'center';
                        
                        errorContainer.innerHTML = `
                            <div style="font-size: 16px; font-weight: 600; color: #d0000f; margin-bottom: 15px;">THREE.OrbitControls未定义</div>
                            <p style="margin: 5px 0; color: #666;">请刷新页面重试，或更换浏览器。</p>
                            <div style="margin-top: 15px;">
                                <p style="margin: 5px 0;">电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</p>
                                <p style="margin: 5px 0;">电芯尺寸: ${cellX}×${cellY}×${cellZ} 厘米</p>
                            </div>
                            <button id="retry-3d-button" style="margin-top: 15px; padding: 8px 15px; background-color: #0071e3; color: white; border: none; border-radius: 8px; cursor: pointer;">刷新页面</button>
                        `;
                        
                        resultDiv.appendChild(errorTitle);
                        resultDiv.appendChild(errorContainer);
                    }
                } else {
                    showErrorView(document.getElementById('result'), 'THREE未定义，无法加载3D视图');
                }
            } catch (error) {
                console.error('设置3D视图时出错:', error);
                // 显示错误信息
                const errorTitle = document.createElement('h3');
                errorTitle.textContent = '3D视图 (加载失败)';
                errorTitle.style.fontSize = isMobile ? '16px' : '18px';
                errorTitle.style.fontWeight = '600';
                errorTitle.style.margin = '30px 0 15px 0';
                errorTitle.style.color = '#1d1d1f';
                
                const errorContainer = document.createElement('div');
                errorContainer.style.width = '100%';
                errorContainer.style.maxWidth = isMobile ? '100%' : '600px';
                errorContainer.style.height = isMobile ? '450px' : '650px'; // 更新错误容器高度
                errorContainer.style.margin = '0 auto 30px auto';
                errorContainer.style.backgroundColor = '#ffefef';
                errorContainer.style.borderRadius = '12px';
                errorContainer.style.display = 'flex';
                errorContainer.style.alignItems = 'center';
                errorContainer.style.justifyContent = 'center';
                errorContainer.style.flexDirection = 'column';
                errorContainer.style.padding = '20px';
                errorContainer.style.textAlign = 'center';
                
                errorContainer.innerHTML = `
                    <div style="font-size: 16px; font-weight: 600; color: #d0000f; margin-bottom: 15px;">3D视图加载失败</div>
                    <p style="margin: 5px 0; color: #666;">${error.message}</p>
                    <div style="margin-top: 15px;">
                        <p style="margin: 5px 0;">电芯排列: ${lengthCount}×${widthCount}×${heightCount} 个</p>
                        <p style="margin: 5px 0;">电芯尺寸: ${cellX}×${cellY}×${cellZ} 厘米</p>
                    </div>
                    <button id="retry-3d-button" style="margin-top: 15px; padding: 8px 15px; background-color: #0071e3; color: white; border: none; border-radius: 8px; cursor: pointer;">刷新页面</button>
                `;
                
                const resultDiv = document.getElementById('result');
                resultDiv.appendChild(errorTitle);
                resultDiv.appendChild(errorContainer);
                
                // 添加重试按钮事件
                setTimeout(() => {
                    const retryButton = document.getElementById('retry-3d-button');
                    if (retryButton) {
                        retryButton.addEventListener('click', function() {
                            // 刷新页面
                            window.location.reload();
                        });
                    }
                }, 100);
            }
        }

        // 清除所有输入
        function clearInputs() {
            // 清除输入值
            document.getElementById('case-length').value = '';
            document.getElementById('case-width').value = '';
            document.getElementById('case-height').value = '';
            document.getElementById('cell-length').value = '';
            document.getElementById('cell-width').value = '';
            document.getElementById('cell-height').value = '';
            
            // 移除所有filled类
            const inputs = document.querySelectorAll('input[type="number"]');
            inputs.forEach(input => {
                input.classList.remove('filled');
            });
            
            document.getElementById('result').style.display = 'none';
        }

        document.addEventListener('DOMContentLoaded', function() {
            // 获取所有输入框
            const inputs = document.querySelectorAll('input[type="number"]');
            
            // 为每个输入框添加事件监听器
            inputs.forEach(input => {
                // 检查localStorage中是否有保存的值
                const savedValue = localStorage.getItem(input.id);
                if (savedValue) {
                    input.value = savedValue;
                    if (input.value.trim() !== '') {
                        input.classList.add('filled');
                    }
                }
                
                // 监听输入变化，改变样式
                input.addEventListener('input', function() {
                    if (this.value.trim() !== '') {
                        this.classList.add('filled');
                    } else {
                        this.classList.remove('filled');
                    }
                    // 保存输入值到localStorage
                    localStorage.setItem(this.id, this.value);
                });
                
                // 初始化时检查是否已有值
                if (input.value.trim() !== '') {
                    input.classList.add('filled');
                }
            });
            
            // 绑定清除按钮事件
            const clearButton = document.getElementById('clear-button');
            if (clearButton) {
                clearButton.addEventListener('click', clearInputs);
            }
        });

        // 添加尺寸标注功能
        function addDimensionLabels() {
            // 添加坐标轴刻度和尺寸标注
            function createAxisWithTicks(start, end, length, tickCount, color, labelText) {
                const tickGroup = new THREE.Group();
                
                // 创建主轴线
                const mainAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...start),
                    new THREE.Vector3(...end)
                ]);
                const mainAxisMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
                const mainAxis = new THREE.Line(mainAxisGeometry, mainAxisMaterial);
                tickGroup.add(mainAxis);
                
                // 创建与轴平行的尺子背景
                const rulerWidth = Math.min(caseLength, caseWidth, caseHeight) * 0.05; // 尺子宽度
                const rulerLength = length;
                let rulerGeometry, rulerPosition;
                
                if (start[0] !== end[0]) { // X轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerLength, rulerWidth);
                    rulerPosition = [start[0] + rulerLength/2, start[1] - rulerWidth/2, start[2]];
                    rulerGeometry.rotateX(-Math.PI/2);
                } else if (start[1] !== end[1]) { // Y轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0] - rulerWidth/2, start[1] + rulerLength/2, start[2]];
                    rulerGeometry.rotateZ(Math.PI/2);
                } else { // Z轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0], start[1] - rulerWidth/2, start[2] + rulerLength/2];
                    rulerGeometry.rotateY(Math.PI/2);
                }
                
                // 创建半透明尺子背景材质
                const rulerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                
                const ruler = new THREE.Mesh(rulerGeometry, rulerMaterial);
                ruler.position.set(...rulerPosition);
                tickGroup.add(ruler);
                
                // 为轴添加刻度线和数值标签
                const tickStep = length / tickCount;
                const majorTickSize = Math.min(caseLength, caseWidth, caseHeight) * 0.04; // 主刻度线大小
                const minorTickSize = majorTickSize * 0.6; // 次刻度线大小
                
                for (let i = 0; i <= tickCount * 5; i++) {
                    // 确定刻度线位置 (包括5个小刻度)
                    const pos = i * (tickStep / 5);
                    const isMajorTick = i % 5 === 0; // 每5个刻度一个主刻度
                    const tickSize = isMajorTick ? majorTickSize : minorTickSize;
                    let tickStart, tickEnd;
                    
                    if (start[0] !== end[0]) { // X轴
                        tickStart = [start[0] + pos, start[1], start[2]];
                        tickEnd = [start[0] + pos, start[1] - tickSize, start[2]];
                    } else if (start[1] !== end[1]) { // Y轴
                        tickStart = [start[0], start[1] + pos, start[2]];
                        tickEnd = [start[0] - tickSize, start[1] + pos, start[2]];
                    } else { // Z轴
                        tickStart = [start[0], start[1], start[2] + pos];
                        tickEnd = [start[0], start[1] - tickSize, start[2] + pos];
                    }
                    
                    // 创建刻度线材质 - 主刻度线更粗更明显
                    const tickMaterial = new THREE.LineBasicMaterial({ 
                        color: color, 
                        linewidth: isMajorTick ? 2 : 1,
                        opacity: isMajorTick ? 1 : 0.7,
                        transparent: true
                    });
                    
                    // 创建刻度线
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...tickStart),
                        new THREE.Vector3(...tickEnd)
                    ]);
                    const tickLine = new THREE.Line(tickGeometry, tickMaterial);
                    tickGroup.add(tickLine);
                    
                    // 只为主刻度添加数值标签
                    if (isMajorTick) {
                        const tickValue = Math.round(pos * 10) / 10; // 保留一位小数
                        
                        // 确定标签位置
                        let labelPos;
                        if (start[0] !== end[0]) { // X轴
                            labelPos = [start[0] + pos, start[1] - tickSize * 1.5, start[2]];
                        } else if (start[1] !== end[1]) { // Y轴
                            labelPos = [start[0] - tickSize * 1.5, start[1] + pos, start[2]];
                        } else { // Z轴
                            labelPos = [start[0], start[1] - tickSize * 1.5, start[2] + pos];
                        }
                        
                        // 创建文字精灵
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 64;
                        canvas.height = 32;
                        
                        // 设置文字样式 - 透明背景
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.font = 'Bold 20px Arial';
                        context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(`${tickValue}`, canvas.width / 2, canvas.height / 2);
                        
                        // 创建纹理
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;
                        
                        // 创建精灵材质 - 透明背景
                        const spriteMaterial = new THREE.SpriteMaterial({ 
                            map: texture,
                            transparent: true
                        });
                        
                        // 创建精灵
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(...labelPos);
                        
                        // 根据物体尺寸调整标签大小
                        const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                        sprite.scale.set(maxDim * 0.04, maxDim * 0.02, 1);
                        
                        tickGroup.add(sprite);
                    }
                }
                
                // 添加轴标签 (例如 "X轴: 30厘米")
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 64;
                
                // 设置文字样式 - 透明背景
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 24px Arial';
                context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`${labelText}: ${length}厘米`, canvas.width / 2, canvas.height / 2);
                
                // 创建纹理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 创建精灵材质 - 透明背景
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true 
                });
                
                // 创建精灵并放置在轴末端之外
                const sprite = new THREE.Sprite(spriteMaterial);
                let labelPosition;
                
                if (start[0] !== end[0]) { // X轴
                    labelPosition = [end[0] + length * 0.05, end[1], end[2]];
                } else if (start[1] !== end[1]) { // Y轴
                    labelPosition = [end[0], end[1] + length * 0.05, end[2]];
                } else { // Z轴
                    labelPosition = [end[0], end[1], end[2] + length * 0.05];
                }
                
                sprite.position.set(...labelPosition);
                
                // 根据物体尺寸调整标签大小
                const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                sprite.scale.set(maxDim * 0.2, maxDim * 0.06, 1);
                
                tickGroup.add(sprite);
                
                scene.add(tickGroup);
                return tickGroup;
            }
            
            // 创建各轴刻度和尺寸标注
            const xAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [caseLength, 0, 0], 
                caseLength, 
                10, // 分10个刻度
                0xff0000, 
                "X轴"
            );
            
            const yAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, caseHeight, 0], 
                caseHeight, 
                10, // 分10个刻度
                0x00ff00, 
                "Y轴"
            );
            
            const zAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, 0, caseWidth], 
                caseWidth, 
                10, // 分10个刻度
                0x0000ff, 
                "Z轴"
            );
            
            // 更新坐标轴标签位置的函数
            function updateLabelPositions() {
                // 定义轴的末端点
                const axisLength = Math.max(caseLength, caseWidth, caseHeight) * 1.2;
                const axes = [
                    { end: new THREE.Vector3(axisLength, 0, 0), label: xAxisLabel },
                    { end: new THREE.Vector3(0, axisLength, 0), label: yAxisLabel },
                    { end: new THREE.Vector3(0, 0, axisLength), label: zAxisLabel }
                ];
                
                // 计算二维坐标
                axes.forEach(axis => {
                    const vector = axis.end.clone();
                    vector.project(camera);
                    
                    // 将归一化的设备坐标(NDC)转换为屏幕坐标
                    const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * container.clientHeight;
                    
                    // 更新标签位置
                    if (axis.label) {
                        axis.label.style.left = x + 'px';
                        axis.label.style.top = y + 'px';
                        
                        // 根据可见性设置显示/隐藏
                        const isVisible = (x >= 0 && x <= container.clientWidth &&
                                        y >= 0 && y <= container.clientHeight &&
                                        vector.z <= 1);
                        axis.label.style.display = isVisible ? 'block' : 'none';
                    }
                });
            }
            
            return updateLabelPositions;
        }

        // 创建尺寸标注并获取更新函数
        const updateDimensionLabels = addDimensionLabels();

        // 修改animate函数，加入标注位置更新
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateDimensionLabels(); // 更新尺寸标注位置
            renderer.render(scene, camera);
        }

        // 在setupRotatable3DMixedView函数中也添加类似的尺寸标注功能
        // 在animate函数前添加
        // 添加尺寸标注功能
        function addMixedDimensionLabels() {
            // 添加坐标轴刻度和尺寸标注
            function createAxisWithTicks(start, end, length, tickCount, color, labelText) {
                const tickGroup = new THREE.Group();
                
                // 创建主轴线
                const mainAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...start),
                    new THREE.Vector3(...end)
                ]);
                const mainAxisMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
                const mainAxis = new THREE.Line(mainAxisGeometry, mainAxisMaterial);
                tickGroup.add(mainAxis);
                
                // 创建与轴平行的尺子背景
                const rulerWidth = Math.min(caseLength, caseWidth, caseHeight) * 0.05; // 尺子宽度
                const rulerLength = length;
                let rulerGeometry, rulerPosition;
                
                if (start[0] !== end[0]) { // X轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerLength, rulerWidth);
                    rulerPosition = [start[0] + rulerLength/2, start[1] - rulerWidth/2, start[2]];
                    rulerGeometry.rotateX(-Math.PI/2);
                } else if (start[1] !== end[1]) { // Y轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0] - rulerWidth/2, start[1] + rulerLength/2, start[2]];
                    rulerGeometry.rotateZ(Math.PI/2);
                } else { // Z轴
                    rulerGeometry = new THREE.PlaneGeometry(rulerWidth, rulerLength);
                    rulerPosition = [start[0], start[1] - rulerWidth/2, start[2] + rulerLength/2];
                    rulerGeometry.rotateY(Math.PI/2);
                }
                
                // 创建半透明尺子背景材质
                const rulerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                
                const ruler = new THREE.Mesh(rulerGeometry, rulerMaterial);
                ruler.position.set(...rulerPosition);
                tickGroup.add(ruler);
                
                // 为轴添加刻度线和数值标签
                const tickStep = length / tickCount;
                const majorTickSize = Math.min(caseLength, caseWidth, caseHeight) * 0.04; // 主刻度线大小
                const minorTickSize = majorTickSize * 0.6; // 次刻度线大小
                
                for (let i = 0; i <= tickCount * 5; i++) {
                    // 确定刻度线位置 (包括5个小刻度)
                    const pos = i * (tickStep / 5);
                    const isMajorTick = i % 5 === 0; // 每5个刻度一个主刻度
                    const tickSize = isMajorTick ? majorTickSize : minorTickSize;
                    let tickStart, tickEnd;
                    
                    if (start[0] !== end[0]) { // X轴
                        tickStart = [start[0] + pos, start[1], start[2]];
                        tickEnd = [start[0] + pos, start[1] - tickSize, start[2]];
                    } else if (start[1] !== end[1]) { // Y轴
                        tickStart = [start[0], start[1] + pos, start[2]];
                        tickEnd = [start[0] - tickSize, start[1] + pos, start[2]];
                    } else { // Z轴
                        tickStart = [start[0], start[1], start[2] + pos];
                        tickEnd = [start[0], start[1] - tickSize, start[2] + pos];
                    }
                    
                    // 创建刻度线材质 - 主刻度线更粗更明显
                    const tickMaterial = new THREE.LineBasicMaterial({ 
                        color: color, 
                        linewidth: isMajorTick ? 2 : 1,
                        opacity: isMajorTick ? 1 : 0.7,
                        transparent: true
                    });
                    
                    // 创建刻度线
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...tickStart),
                        new THREE.Vector3(...tickEnd)
                    ]);
                    const tickLine = new THREE.Line(tickGeometry, tickMaterial);
                    tickGroup.add(tickLine);
                    
                    // 只为主刻度添加数值标签
                    if (isMajorTick) {
                        const tickValue = Math.round(pos * 10) / 10; // 保留一位小数
                        
                        // 确定标签位置
                        let labelPos;
                        if (start[0] !== end[0]) { // X轴
                            labelPos = [start[0] + pos, start[1] - tickSize * 1.5, start[2]];
                        } else if (start[1] !== end[1]) { // Y轴
                            labelPos = [start[0] - tickSize * 1.5, start[1] + pos, start[2]];
                        } else { // Z轴
                            labelPos = [start[0], start[1] - tickSize * 1.5, start[2] + pos];
                        }
                        
                        // 创建文字精灵
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 64;
                        canvas.height = 32;
                        
                        // 设置文字样式 - 透明背景
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.font = 'Bold 20px Arial';
                        context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(`${tickValue}`, canvas.width / 2, canvas.height / 2);
                        
                        // 创建纹理
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;
                        
                        // 创建精灵材质 - 透明背景
                        const spriteMaterial = new THREE.SpriteMaterial({ 
                            map: texture,
                            transparent: true
                        });
                        
                        // 创建精灵
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(...labelPos);
                        
                        // 根据物体尺寸调整标签大小
                        const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                        sprite.scale.set(maxDim * 0.04, maxDim * 0.02, 1);
                        
                        tickGroup.add(sprite);
                    }
                }
                
                // 添加轴标签 (例如 "X轴: 30厘米")
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 64;
                
                // 设置文字样式 - 透明背景
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 24px Arial';
                context.fillStyle = color === 0xff0000 ? '#ff0000' : color === 0x00ff00 ? '#00ff00' : '#0000ff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`${labelText}: ${length}厘米`, canvas.width / 2, canvas.height / 2);
                
                // 创建纹理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 创建精灵材质 - 透明背景
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true 
                });
                
                // 创建精灵并放置在轴末端之外
                const sprite = new THREE.Sprite(spriteMaterial);
                let labelPosition;
                
                if (start[0] !== end[0]) { // X轴
                    labelPosition = [end[0] + length * 0.05, end[1], end[2]];
                } else if (start[1] !== end[1]) { // Y轴
                    labelPosition = [end[0], end[1] + length * 0.05, end[2]];
                } else { // Z轴
                    labelPosition = [end[0], end[1], end[2] + length * 0.05];
                }
                
                sprite.position.set(...labelPosition);
                
                // 根据物体尺寸调整标签大小
                const maxDim = Math.max(caseLength, caseWidth, caseHeight);
                sprite.scale.set(maxDim * 0.2, maxDim * 0.06, 1);
                
                tickGroup.add(sprite);
                
                scene.add(tickGroup);
                return tickGroup;
            }
            
            // 创建各轴刻度和尺寸标注
            const xAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [caseLength, 0, 0], 
                caseLength, 
                10, // 分10个刻度
                0xff0000, 
                "X轴"
            );
            
            const yAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, caseHeight, 0], 
                caseHeight, 
                10, // 分10个刻度
                0x00ff00, 
                "Y轴"
            );
            
            const zAxisTicks = createAxisWithTicks(
                [0, 0, 0], 
                [0, 0, caseWidth], 
                caseWidth, 
                10, // 分10个刻度
                0x0000ff, 
                "Z轴"
            );
            
            // 更新坐标轴标签位置的函数
            function updateLabelPositions() {
                // 定义轴的末端点
                const axisLength = Math.max(caseLength, caseWidth, caseHeight) * 1.2;
                const axes = [
                    { end: new THREE.Vector3(axisLength, 0, 0), label: xAxisLabel },
                    { end: new THREE.Vector3(0, axisLength, 0), label: yAxisLabel },
                    { end: new THREE.Vector3(0, 0, axisLength), label: zAxisLabel }
                ];
                
                // 计算二维坐标
                axes.forEach(axis => {
                    const vector = axis.end.clone();
                    vector.project(camera);
                    
                    // 将归一化的设备坐标(NDC)转换为屏幕坐标
                    const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * container.clientHeight;
                    
                    // 更新标签位置
                    if (axis.label) {
                        axis.label.style.left = x + 'px';
                        axis.label.style.top = y + 'px';
                        
                        // 根据可见性设置显示/隐藏
                        const isVisible = (x >= 0 && x <= container.clientWidth &&
                                        y >= 0 && y <= container.clientHeight &&
                                        vector.z <= 1);
                        axis.label.style.display = isVisible ? 'block' : 'none';
                    }
                });
            }
            
            return updateLabelPositions;
        }

        // 创建尺寸标注并获取更新函数
        const updateMixedDimensionLabels = addMixedDimensionLabels();

        // 修改animate函数，加入标注位置更新
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateMixedDimensionLabels(); // 更新尺寸标注位置
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
